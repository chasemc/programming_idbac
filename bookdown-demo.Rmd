--- 
title: "Programming with IDBac"
author: "Chase Clark"
date: "`r Sys.Date()`"
#site: bookdown::bookdown_site
output: bookdown::pdf_book
documentclass: book
#bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: chasemc/programmingidbac
description: "This contains some examples on how to program with IDBac; rather than, or complementing, using the Shiny app."
---

# Preamble

While some familiarity with R is suggested, the examples laid out within this book should be explantory enough for a novice to comfortable working through.

Suggestions or additions for content are welcome and may contributed at github.com/chasemc/programmingidbac Note that this project has a contributor covenenant TODO. 


## Major points:

Things you want to do will revolve around:

  - Creating an IDBac database from your raw (or converted) data
  - Moving data from one IDBac database to another
  - Accessing spectra 
  - Accessing peak-picked data
  - Filtering data by some attribute



## Download IDBac example file

The data used in this book uses example data that can be found here:
ftp://massive.ucsd.edu/MSV000084291

```{r}
library(here)
```

Let's download an IDBac experiment file (SQLite database).
```{r}

if (!file.exists(here::here("data",
                            "example_data",
                            "idbac_experiment_file.sqlite"))) {
  
  # Create a directory to download the example data to:
  dir.create(here::here("data"))
  dir.create(here::here("data",
                        "example_data"))
  # URL of example file
  ex_url <- "ftp://massive.ucsd.edu/MSV000084291/raw/data/idbac_experiment_file.sqlite"
  
  # Download example file ("wb" is important here)
  download.file(url = ex_url,
                destfile = here::here("data",
                                      "example_data",
                                      "idbac_experiment_file.sqlite"),
                mode = "wb")
}
```




<!--chapter:end:index.Rmd-->


# Connect to an IDBac Database


Load the necessary packages for this tutorial:
```{r eval=TRUE, message=FALSE, warning=FALSE, include=TRUE}
library(IDBacApp)
```



## Connect to IDBac database

Here we will make a connection to the database. 

Under the hood IDBac uses the `{pool}` package and some IDBac functions expect a `pool` object and thus it is the preferred method besides `IDBacApp::createPool()`


```{r}
example_pool <- IDBacApp::createPool(fileName = "idbac_experiment_file",
                                     filePath = here::here("data",
                                                "example_data"))

```

Besides IDBacApp::createPool(),
```
DBI::dbConnect(RSQLite::SQLite(), 
ex_path)
```
or
```
pool::dbPool(drv = RSQLite::SQLite(),
dbname = ex_path)
```
can also be used. 



Notice that this isn't a pool object, it's a list (this is for a reason- it helps the IDBac Shiny app make multiple connections).

```{r}
class(example_pool)
```

To get our pool object let's pull it out of the list.
```{r}
# example_pool$idbac_experiment_file would also work 
example_pool <- example_pool[[1]]
class(example_pool)
```

You should now be connected to an IDBac experiment/database!

<!--chapter:end:01_connect-to-database.Rmd-->


# IDBac Databases Explained


Load necessary packages for this tutorial:
```{r eval=TRUE, message=FALSE, warning=FALSE, include=TRUE}
library(IDBacApp)
# dplyr is for easily working with SQLite databases
library(dplyr)
# DBI is used to communicate with SQLite databases
library(DBI)
# pool manages SQLite database connections
library(pool)
```


First, download the example `idbac_experiment_file.sqlite` file.



Connect to the database


```{r}
example_pool <- IDBacApp::createPool(fileName = "idbac_experiment_file",
                                     filePath = here::here("data",
                                                "example_data"))

```

To get our pool object let's pull it out of the list.
```{r}
# example_pool$idbac_experiment_file would also work 
example_pool <- example_pool[[1]]
class(example_pool)
```

## Database Tables

IDBac has 6 tables which we'll go through one by one.

```{r}
cat(rev(DBI::dbListTables(example_pool)),
    sep = "\n")
```


### The `Version` table
```{r}
dplyr::tbl(example_pool,
           "Version")
```

This table contains two fields `IDBacVersion` and `rVersion`.

`IDBacVersion`  is the version of IDBac that was used to create the database
`rVersion` contains information on the version of R used to create the database. It is a JSON string and can be easily parsed using the `{JSONlite}` R package (among many others).

```{r}
a <- dplyr::tbl(example_pool,
           "Version") %>% collect()

jsonlite::fromJSON(a$rVersion)
```






### The `locale` table
```{r}
dplyr::tbl(example_pool,
           "locale")
```

This table can be ignored. It stores the encodings used when creating the database. Its only real purpose is for debugging. 


### The `metaData` table
```{r}
dplyr::tbl(example_pool,
           "metaData")
```

This table starts out empty except for the field `Strain_ID`. It is to be filled in by the user, usually using the IDBac Shiny interface. It contains "extra" information about each sample.






### The `massTable` table
```{r}
dplyr::tbl(example_pool,
           "massTable")
```


This is a good time to explain some (very) basic SQL and hashing, I will try to keep things simple and accessible. 

SQL is pretty cool because it allows you to structure your data to "hopefully" store things a minimum number of times. So we can store a data point once even if it relates to multiple other points- as long as we can reference this relationship. When retrieving results we merge mutliple tables together using these references and voila!

In the case of `massTable` I noticed that, at least on the Bruker autoFlex instruments, all data collected using the same settings will contain the same exact `m/z` values for a mass spectrum. This means that, while we do have to store intensity values for every spectrum, we can potentially save space by only soring uniquee `m/z` vectors (the `massVector` field).


That brings us to the field `spectrumMassHash`. This is a short representation of the mass vectors that allows us to quickly reference a specfic mass vector as well as determine if a `massVector` is the same or different to a `massVector` already stored in the database. The importance of this will be more apparant later.





### The `XML` table
```{r}
dplyr::tbl(example_pool,
           "XML")
```

The `XML` table stores the mzML (or mzXML of that was the input type) files and some basic information about the instrument if that information was available (e.g. information won't be present if spectra were converted from txt files). The `XML` field contains the compressed mzML/mzXML file, in full.



### The `IndividualSpectra` table
```{r}
dplyr::tbl(example_pool,
           "IndividualSpectra")
```


And a full list of columns:

```{r}
a <- dplyr::tbl(example_pool,
           "IndividualSpectra")

colnames(a)
```

This is, inarguably, the most important table of the database. It is sample-level data (each row represents a single spectrum) and includes data like: `spectrumIntensity`, peak data `peakMatrix`, `maxMass`, `minMass`, etc.

The input for many of the fields (e.g. `massError`, `tofMode`) are extracted from Bruker's `acqus` files and so will only be present if you used IDBac to process Bruker raw data files directly.



## How do I use this????

Please see the other vignettes to see how make use of the databases. 








<!--chapter:end:02_idbac-databases-explained.Rmd-->


# Simple Analysis


Load necessary packages for this tutorial:
```{r message=FALSE, warning=FALSE, include=FALSE}
library(IDBacApp)
library(dplyr)
library(DBI)
library(pool)
library(sda)
```


If you haven't already, connect to an IDBac database as shown in "01_connect-to-idbac-database".
Connect to the database


```{r}
example_pool <- IDBacApp::createPool(fileName = "idbac_experiment_file",
                                     filePath = here::here("data",
                                                "example_data"))

```

To get our pool object let's pull it out of the list.
```{r}
# example_pool$idbac_experiment_file would also work 
example_pool <- example_pool[[1]]
class(example_pool)
```


## Check database

What samples are in the database?
```{r}

dplyr::tbl(example_pool, "IndividualSpectra") %>%  # Specifiy database and table to get data from
select("Strain_ID") %>% # Select "Strain_ID" field/column
  distinct() # Only show unique strain ids

```



```{r message=FALSE, warning=FALSE}
my_plot <- IDBacApp::assembleMirrorPlots(sampleID1 = "172-7",
                                         sampleID2 = "172-10",
                                         peakPercentPresence = 0.7,
                                         lowerMassCutoff = 3000,
                                         upperMassCutoff = 15000,
                                         minSNR = 4, 
                                         tolerance = 0.002,
                                         pool1 = example_pool,
                                         pool2 = example_pool)
IDBacApp::mirrorPlot(my_plot)

```

The interactive graph above can be slow to generate with larger data. IDBac also has a base-R implementation that is faster to create but is non-interactive/static:
```{r}
IDBacApp::baserMirrorPlot(my_plot)
```

















































We'll leave the replicates in right now:
```{r}

my_peaks <- IDBacApp::collapseReplicates(pool = example_pool,
                                         sampleIDs = c("172-10", "172-7", "172-1", "172-11"),
                                         peakPercentPresence = 0.6,
                                         lowerMassCutoff = 3000,
                                         upperMassCutoff = 15000, 
                                         minSNR = 4, 
                                         tolerance = 0.002,
                                         protein = TRUE)



my_fuzz <- IDBacApp::createFuzzyVector(massStart = 3000,
                                       massEnd = 15000,
                                       ppm = 500,
                                       massList = lapply(my_peaks, function(x) x@mass),
                                       intensityList = lapply(my_peaks, function(x) x@intensity))

```

`my_fuzz` is now a high-dimensional representation of your peaks and the given ppm tolerance
```{r}
plot(my_fuzz[,1], type = "l")
plot(my_fuzz[,1], type = "l", xlim=c(4500,5000))
points(my_fuzz[,1], xlim=c(4500,5000))
```

...and you can use this for things like calculating cosine similarity, creating dendrograms, etc.

```{r}
1 - coop::cosine(my_fuzz)
```



**Note!**
`IDBacApp::createFuzzyVector()` returns a sparse matrix which requires some special handling and the high-dimensional nature of this may break algorithms that don't work well with sparse-matrices.
```{r}
class(my_fuzz)
```

### PCA
Notice how most of the variation here (PC1) separates *Paenibacillus* strains (172-10 and 172-7) from the *Rhodococcus* strains (172-1 and 172-11). PC2 seems to contain information relating to differences between the two *Paenibacillus* strains.
```{r}
w <- stats::prcomp(Matrix::t(my_fuzz), center = T)

plot(w$x, xlim = c(-5000,5000), ylim = c(-5000,5000))
text(w$x, colnames(my_fuzz))
```

### UMAP (Note: really shouldn't use with this few of samples)
```{r}
my_dist <- as.dist(coop::cosine(my_fuzz))

w <- uwot::umap(my_dist, n_neighbors =2)

plot(w)
text(w, attributes(my_dist)$Labels)
```

### Principle coordinates analysis (PCoA)
```{r}
w <- IDBacApp::pcoaCalculation( as.dist(1 - coop::cosine(my_fuzz))) #Note the subtraction from 1
plot(w$Dim1, w$Dim2)
text(w$Dim1, w$Dim2, w$nam)
```



Want to do something like you see in the {MALDIquant} documentation?

Examples below are from:
https://github.com/sgibb/MALDIquantExamples/
Specifically: https://github.com/sgibb/MALDIquantExamples/blob/master/inst/doc/species.pdf?raw=true

```{r}
names(my_peaks)
```


```{r}

my_peaks <- IDBacApp::collapseReplicates(pool = example_pool,
                                         sampleIDs = c("172-10", "172-7", "172-1", "172-11"),
                                         peakPercentPresence = 0.6,
                                         lowerMassCutoff = 3000,
                                         upperMassCutoff = 15000, 
                                         minSNR = 4, 
                                         tolerance = 0.002,
                                         protein = TRUE)

my_peaks <- MALDIquant::binPeaks(my_peaks)
 species <- factor(c("Paenibacillus", "Paenibacillus","Rhodococcus", "Rhodococcus"))


featureMatrix <- MALDIquant::intensityMatrix(my_peaks)
rownames(featureMatrix) <- paste(species,
                  names(my_peaks), sep=".")
featureMatrix[is.na(featureMatrix)] <- 0.001

ddar <- sda.ranking(Xtrain=featureMatrix, L=species, fdr=FALSE, diagonal=T)

```

```{r}
plot(ddar)
```



```{r}
ldar <- sda.ranking(Xtrain=featureMatrix, L=species,
fdr=FALSE, diagonal=FALSE)
```

```{r}
plot(ldar)
```


<!--chapter:end:05_simple-data-analysis.Rmd-->

